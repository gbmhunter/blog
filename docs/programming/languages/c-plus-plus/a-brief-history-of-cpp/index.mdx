---
authors: [ "Geoffrey Hunter" ]
categories: [ "Programming", "Languages", "C++" ]
date: 2019-08-20
description: ""
draft: false
last_update:
  date: 2019-08-20
  author: Geoffrey Hunter
tags: [ "programming", "languages", "C++" ]
title: "A Brief History Of C++"
type: "page"
---

## Overview

## C++98

## C++03

C++03 introduced the first smart pointer as `std::auto_ptr`, although this was found to contain some serious design flaws, and was deprecated in `C++11`.

`C++03` also introduced the concept of value initialization for automatic objects.

```c++
// Pre C++03
int any_number; // The value of this could be anything (this is quick)!

// C++03
int value_initialized(); // Value is guaranteed to be 0
int a[9] = {}; // 
```

`C++03` was the first C++ version to specify that `std::vector` must store it's elements in a contiguous memory space (most implementations already did this, but it was not enforced).

## C++11

You could argue that C++ underwent the largest change ever in `C++11`.

* `C++11` introduces the first threading concepts such as `std::thread` into the standard library, largely eliminating the need for using device specific APIs such as `pthread` (Linux) or `CreateThread` (Windows). Along with `std::thread`, a large number of essential concurrent programming primitives such as `std::mutex` and `std::lock_guard` were added.

* `C++11` also "fixed" the `std::auto_ptr` smart pointer introduced in C++03. As a replacement, `C++11` introduced the `std::unique_ptr`, `std::shared_ptr` and `std::weak_ptr` types.

* `C++11` introduced the `auto` keyword, which you can use instead of having to specify the full type of a variable, as long as the compiler can work it out from the context surrounding it.

    ```c++
    // Before C++11
    std::vector<std::string>* my_var = new std::vector<std::string>();

    // C++11
    auto my_var = new std::vector<std::string>();
    ```

    This `auto` can save a lot of unnecessary typing, as well as making refactoring easier.

* `C++11` introduced lambdas to the language. You can now define an anonymous function inside another function, and it can capture local variables from within the context of where it lambda was created (it is important to remember that the lambda will not automatically extend the lifetime of the variables).

    ```c++
    void my_func() {

    }
    ```

* A new "Python-like" way of creating a for-loop that iterates over a container:

    ```c++
    for(auto my_element: my_container) {
      // Do something
    }
    ```

* `C++11` introduced _initializer lists_, which are a way of initializing containers with inline lists:

    ```c++
    std::vector<int> my_vector = { 0, 1, 2, 3 };
    ```

* `C++11` was the first version to allow a class constructor to call another constructor belonging to the same class. This is to make code tidier when a class has many constructor signatures and they all share similar base code.

## C++14

`C++14` was largely an incremental improvement on the features introduced in `C++11`.

## C++17

`C++17` introduced the concept of unpacking via `{` and `}`.

## C++20