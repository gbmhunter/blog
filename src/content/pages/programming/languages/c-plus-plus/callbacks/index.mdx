---
authors: [gbmhunter]
date: 2014-01-17
description: How to deal with the tricky issue of callbacks in C++ (incl. how to provide member functions to C-style callbacks), especially in embedded environments.
image: ./_assets/cpp-callbacks.png
lastUpdated: 2022-08-21
tags: [programming, languages, C++, callbacks, methods, functors, functions, Vlpp, libsigc++, signals, slots, callee, embedded, functional, 'std::bind', bind]
title: C++ Callbacks (and giving member functions to C-style callbacks)
type: page
---

Callbacks are functions (or more generally --- any object that is callable) which are passed to other functions (or modules, libraries e.t.c) that then call the function at their choosing. They are useful for eliminating dependencies between modules, and are used for example for libraries to call your application code.

<Image src={import('./_assets/callback.png')} width="500px"/>

C++, being a strongly-typed object-orientated language, makes callbacks a tricker subject to deal with than say, in C (non-object orientated) or Javascript (object orientated but NOT strongly typed). **This is especially true for embedded systems where you cannot always rely on having newer C++ standard library header files** such as `<functional>` at your disposal (it's a mixed bag, some embedded C++ environments I've used do support `<functional>`, others do not).

<Aside type="note">
I have written an open-source C++ callback library called slotmachine-cpp, which you can download from [GitHub here](https://github.com/gbmhunter/slotmachine-cpp).
</Aside>

Working code for all the example below can be found at [https://github.com/gbmhunter/blog-cpp-callbacks](https://github.com/gbmhunter/blog-cpp-callbacks).

## Terminology

First, let's get some terminology out of the way:

<table>
    <colgroup>
       <col span="1" style={{ width: '100px' }}/>
       <col span="1" style={{ width: '400px' }}/>
    </colgroup>
    <thead>
        <tr>
            <th>Term</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Callee</td>
            <td>A function/method/object which gets called by the caller.</td>
        </tr>
        <tr>
            <td>Caller</td>
            <td>An object which gets passes a callback function, and then calls (executes) it.</td>
        </tr>
        <tr>
            <td>Function</td>
            <td>A basic function that does not require an instance of a class to run (e.g. standard C style functions, or static member functions).</td>
        </tr>
        <tr>
            <td>Method</td>
            <td>A function that belongs to an class, and requires an instance of the class to run (i.e. the `this` pointer).</td>
        </tr>
        <tr>
            <td>Signals</td>
            <td>Term used for "events" in an event/listener system.</td>
        </tr>
        <tr>
            <td>Slots</td>
            <td>Term used for objects which listen to signals in an event/listener system. These are normally implemented with a callback system.</td>
        </tr>
    </tbody>
</table>

## The Primitive C++ Callback: The Caller Knows The Type Of The Callee 

The problem arises when you want to pass in a non-static method (function belonging to an class, that requires an instance of that class) as a callback to a library. A method is a member function of an object. To call a method, you can't just know the functions memory address and call it, you also have to know the object that the function belongs to (the `this` pointer!).

This means that for C++ method callbacks in their most primitive form, **the callee has to know the type of the object the function belongs to**. For example:

```c++ title="main.cpp"
#include <cstdio>

class MyClass {
public:
    // This is our application callback handler for when a message is received, we will
    // pass this into the library which deals with message parsing
        void onMsg(int num1, int num2) {
        printf("onMsg() called with num1=%i, num2=%i\n", num1, num2);
    }
};

class LibraryClass {
public:
    // For the library class to call the onMsg, it has to be passed both an instance
    // of MyClass and a pointer to the member function to call
    // Note that MyClass has to be known here! This creates undesired coupling...in
    // reality your library should never have to know about MyClass
    void passACallbackToMe(MyClass* myClass, void (MyClass::* onMsg)(int num1, int num2)) {
        // Call the callback function
        (myClass->*onMsg)(1, 2);
    }
};

int main() {
    MyClass myClass;
    LibraryClass libraryClass;

    // Provide the instance and function to call
    libraryClass.passACallbackToMe(&myClass, &MyClass::onMsg);
}
```

## Using Static Methods Or Non-Member Functions (C-Style)

If you are stuck with a C-style callback, there is no direct way to call non-static (i.e. takes a `this` pointer as the magic first parameter) member function. You can however easily call static member functions (they are no different in type signature to C-style functions):

```c++ title="main.cpp"
#include <cstdio>

class MyClass {
public:
    // This is our application callback handler for when a message is received, we will
    // pass this into the library which deals with message parsing
    // The "static" keyword makes it easy, as now this function does not
    // take a this pointer and has the same signature as a plain C function
    static void onMsg(int num1, int num2) {
        printf("onMsg() called with num1=%i, num2=%i\n", num1, num2);
        // NOTE: Can't call any non-static method functions here!
    }
};

class LibraryClass {
public:
    // For the library class to call the onMsg, it has to be passed both an instance
    // of MyClass and a pointer to the member function to call
    // Note that MyClass has to be known here! This creates undesired coupling...in
    // reality your library should never have to know about MyClass
    void passACallbackToMe(void (*onMsg)(int num1, int num2)) {
        // Call the callback function
        onMsg(1, 2);
    }
};

int main() {
    MyClass myClass;
    LibraryClass libraryClass;

    // Provide the instance and function to call
    libraryClass.passACallbackToMe(&myClass.onMsg);
}
```

Note the main limitation of the above method is that no non-static member functions can be called. This limits how "object orientated" you can get with your software/firmware architecture.

## Calling Member Functions Via Standard C Function

As we touched on before, if you are stuck with a C-style callback, there is no direct way to call a member function. However, given we can call static methods (as shown directly above), we can use shared variables (e.g. file scoped variables) to call a particular instance from that static function. This is about the best you can do when you want to call a C++ class member function, but you have to provide a C-style callback.

Let's go through an example, this time using a standard C function rather than a static member function purely for illustration they are interchangeable:

```c++
#include <cstdio>
#include <functional>

class LibraryClass {
public:
	  void passACallbackToMe(int (*callback)(int num1, int num2)) {
	      // Now invoke (call) the callback
        int o = callback(1, 2);
        printf("Value: %i\n", o); // We might be on an embedded system, use printf() and not std::cout
	  }
};

class MyClass {
public:
      int methodToCallback(int num1, int num2) {
          return num1 + num2;
      }
};

// Global pointer to an instance of our class so the C style callback
// wrapper can invoke the callback on a particular instance (yuck!)
MyClass * myClassPtr;
int cStyleWrapper(int num1, int num2) {
    return myClassPtr->methodToCallback(num1, num2);
}

int main()
{
    MyClass myClass;
    // Make the global variable point to our new instance. Obviously, this
    // way does not scale well, as you have to make global variable and C-style
    // function for every instance (and what if you don't know how many instances you will
    // need!?!)
    myClassPtr = &myClass; 
    
    LibraryClass libraryClass;
    libraryClass.passACallbackToMe(&cStyleWrapper);
}
```

## Static Variables, With Templating

A slightly more complicated but flexible approach to the above is to use templating, `std::bind` and `std::function` as shown in the below example:

```c++
#include <stdio.h>
#include <functional>

template <typename T>
struct Callback;

template <typename Ret, typename... Params>
struct Callback<Ret(Params...)> {
   template <typename... Args> 
   static Ret callback(Args... args) {
      return func(args...);  
   }
   static std::function<Ret(Params...)> func; 
};

template <typename Ret, typename... Params>
std::function<Ret(Params...)> Callback<Ret(Params...)>::func;

// C-style API which just wants a standard function for callback
void c_function_which_wants_callback(int (*func)(int num1, int num2)) {
   int o = func(1, 2);
   printf("Value: %i\n", o);
}

class ClassWithCallback {
   public:
      int method_to_callback(int num1, int num2) {
          return num1 + num2;
      }
};

typedef int (*callback_t)(int,int);

int main() {
    ClassWithCallback my_class;
    Callback<int(int,int)>::func = std::bind(&ClassWithCallback::method_to_callback, &my_class, std::placeholders::_1, std::placeholders::_2);
    callback_t func = static_cast<callback_t>(Callback<int(int,int)>::callback);

    // Now we can pass this function to a C API which just wants a standard function callback    
    c_function_which_wants_callback(func);
}
```

## Templating the Member Function and Instance

If you have control over the module accepting the callback, one option you can use is to use templating on the passed in callback member function and instance. For example:

```c++
#include <cstdio>

template <typename T, typename U>
class LibraryClass {
public:
    LibraryClass(T callback, U& instance) : callback(callback), instance(instance) {}

    void run() {
        (instance.*callback)(1, 2);
    }
private:
    T callback;
    U& instance;
};

class MyClass {
public:
    void methodToCallback(int num1, int num2) {
        printf("methodToCallback() called with num1=%i, num2=%i\n", num1, num2);
    }
};

int main() {
    MyClass myClass;
    LibraryClass libraryClass(&MyClass::methodToCallback, myClass);
    libraryClass.run();
}
```

`LibraryClass` is templated on two parameters, the member function pointer type `T` and the type of the class `U`. These are automatically deduced by the compiler when the `LibraryClass` object is constructed.

Pros and cons of this approach are:

* PRO: No reliance on `std::function` and `std::bind` or lambdas.
* CON: The library class has to be templated on all class types and member functions that will be used as callback. This is not so much of an issue for the basic example shown above, but could quickly get out of hand with a few different callbacks (especially so if you wanted to call member functions of different user classes!).
* CON: You can't use a basic C function as a callback, this approach forces you to use a member function. `std:function` and `function_ref` allow you to support almost any "callable" object.
* CON: Although faster than `std::function`, it's still slower than `function_ref` which is arguably better in every way (see the Benchmarking section below for more details).

## Callback Interface Using Inheritance

Another approach if you have control over the module accepting the callback is to use an interface class to define the callback signature. For example:

```c++
#include <cstdio>

/**
 * This defines the interface of the "callbackable" class.
 */
class CallbackInterface {
public:
    virtual void methodToCallback(int num1, int num2) = 0;
};

class LibraryClass {
public:
    LibraryClass(CallbackInterface* callback) : callback(callback) {}
    void run() {
        // Call the callback function
        callback->methodToCallback(1, 2);
    }
private:
    CallbackInterface* callback;
};

/**
 * Our class inherits from the interface.
 */
class MyClass : public CallbackInterface {
public:
    void methodToCallback(int num1, int num2) {
        printf("onMsg() called with num1=%i, num2=%i\n", num1, num2);
    }
};

int main() {
    MyClass myClass;
    LibraryClass libraryClass(&myClass);
    libraryClass.run();
}
```

`CallbackInterface` is a pure virtual class which defines an interface for the callback. `LibraryClass` accepts a pointer to an instance of this interface and will call the `methodToCallback` method. To create a callback, `MyClass` inherits from `CallbackInterface` and implements the `methodToCallback` method.

* PRO: Simple to understand and implement (arguably easier to read than the "Templating the Member Function and Instance" approach).
* PRO: Fast! Even though there is a virtual function call (i.e. vtable lookup), this method out performed many others in the benchmarking tests (see below).
* CON: You can't use a basic C function as a callback, this approach forces you to use a member function. `std:function` and `function_ref` allow you to support almost any "callable" object.
* CON: The library class has to define the callback interface and the exact names of the callback methods. This prevents you from arbitrarily providing any function as the callback and is a rather rigid approach.
* CON: With multiple callbacks, the library has two choices. Either define all the callbacks in a single interface, which restricts a single user class to implement all the callbacks, or define a new interface for each callback, which would mean multiple inheritance if you wanted the same class to handle multiple callbacks. Neither of these options are ideal.

## std::function With std::bind

`std::function` is a common type to use for a callback in modern C++. For this technique you need to have control over the caller so that you can use the `std::function` type (if you can't, and are stuck with a C-style callback type, see the above sections). There are two main ways to create a `std::function` object from a member function, one is to use `std::bind` and the other is to use a lambda. Let's cover the `std::bind` technique first.

The following code example shows how to do this. Rather than the callback type being `int (callback*) (int num1, int num2)`, we know change it to `std::function<int(int, int)>`. `<int(int, int)>` defines the type signature of the callback, which is a function which takes two `int` parameters and returns an `int`.

`std::bind` is used to pass a member function to this callback. Notice the syntax is quite verbose. It requires the following syntax: `std::bind(<pointer-to-member-function>, <instance-of-class>, <input-1-placeholder>, <in>)`. 

```c++
#include <cstdio>
#include <functional>

class MyClass {
public:
    int methodToCallback(int num1, int num2) {
        return num1 + num2;
    }
};

void passACallbackToMe(std::function<int(int, int)> callback) {
    int o = callback(1, 2);
    printf("Value: %i\n", o);
}

int main()
{
    MyClass myClass;
    passACallbackToMe(std::bind(&MyClass::methodToCallback, myClass, std::placeholders::_1, std::placeholders::_2));
}
```

## std::function With Lambdas

An alternative to using `std::bind` to pass your member function to the `std::function` is to use a lambda instead. This approach may avoid the dynamic memory allocation of `std::bind` for a small number of captured variables (such as just `this`). Similarly to `std::bind`, a downside is that you have to repeat the function arguments again in the definition of the lambda.

The following code example shows how to do this:

```c++
#include <cstdio>
#include <functional>

class MyClass {
public:
    int methodToCallback(int num1, int num2) {
        return num1 + num2;
    }
};

void passACallbackToMe(std::function<int(int, int)> callback) {
    int o = callback(1, 2);
    printf("Value: %i\n", o);
}

int main()
{
    MyClass myClass;
    
    // Use a lambda to capture myClass and call the member method
    passACallbackToMe([&myClass](int num1, int num2) -> int {
        return myClass.methodToCallback(num1, num2);
    });
}
```

## function_ref

An faster, non dynamic memory allocation alternative to `std::function` is `function_ref`. I use the term `function_ref` to refer to a concept in which there a number of implementations. The first standarized one is hitting the standard library in C++26, which as of mid-2025 is not widely supported by compilers (and good luck trying to get a company to adopt a standard on the bleeding edge). However, there are also 3rd party implementations that you can use today.

`function_ref` is a non-owning function wrapper.

From cppreference.com:

> Class template `std::function_ref` is a non-owning function wrapper. `std::function_ref` objects can store and invoke reference to Callable target - functions, lambda expressions, bind expressions, or other function objects, but not pointers to member functions and pointers to member objects.[^cpp-reference-std-function-ref]

The following code example uses the `zhihaoy/nontype_functional` library.

```c++
#include <cstdio>

#include <std23/function_ref.h>

class MyClass {
public:
      int methodToCallback(int num1, int num2) {
          return num1 + num2;
      }
};

void passACallbackToMe(std23::function_ref<int(int, int)> callback) {
    int o = callback(1, 2);
    printf("Value: %i\n", o); // We might be on an embedded system, use printf() and not std::cout
}

int main()
{
    MyClass myClass;
    passACallbackToMe({std23::nontype<&MyClass::methodToCallback>, myClass});
}
```

Note the callback is now of type `std23::function_ref<int(int, int)>`. To pass a member function to this callback, we use `std23::nontype` on the member function pointer and pass this along with the instance of the class we wish to call. This has an improvement over both `std::function` techniques (`std::bind` and lambdas) in that you don't have to repeat the function arguments!

### 3rd Party Implementations

As of mid-2025, C++26 support is not widespread among the popular compilers. And good luck trying to get a company to adopt a standard on the bleeding edge. Luckily, there are 3rd party implementations of essentially the same thing as `std::function_ref`. The GitHub repo [zhihaoy/nontype_functional](https://github.com/zhihaoy/nontype_functional) contains a complete implementation of the `std::function`, `std::function_ref`, and `std::move_only_function` equivalent to those in the C++26 `<functional>` header.[^github-zhihaoy-nontype-functional]

zhihaoy/nontype_functional can be easily included in your CMake based project using `FetchContent`:

```cmake title="CMakeLists.txt"
include(FetchContent)
FetchContent_Declare(
  nontype_functional
  GIT_REPOSITORY https://github.com/zhihaoy/nontype_functional
  GIT_TAG        bdb098751ccdba3e03b429064473c70e228a885e # v1.0.2
)
FetchContent_MakeAvailable(nontype_functional)
```

For a lighter implementation, the GitHub repo [TartanLlama/function_ref](https://github.com/TartanLlama/function_ref) provides just a `tl::function_ref` implementation. It describes itself as "a lightweight non-owning reference to a callable".

<Aside type="note">
The example of the README of `TartanLlama/function_ref` is:

Use `tl::function_ref` instead of `std::function` whenever you don't need to own the callable. The most common case for this is function parameters which aren't stored anywhere:

```c++
void foo (function_ref<int(int)> func) {
    std::cout << "Result is " << func(21); //42
}

foo([](int i) { return i*2; });
```
</Aside>

A working `std::function_ref` example using `zhihaoy/nontype_functional` can be found at https://github.com/gbmhunter/blog-cpp-callbacks/tree/main/using-std-function-ref.

## Benchmarking

I benchmarked some of the different callback techniques above to compare how quickly they run. Most of the time you wouldn't care about these performance differences, as the callbacks are not part of some critical execution path. However, in certain situations you will care! Some examples might be if you had a callback that fired on every received byte of a high bandwidth communication protocol, or a callback as part of some fast running control loop.

Benchmarking was performed with [Google Benchmark](/programming/languages/c-plus-plus/google-benchmark/). The benchmark results are shown below:

<table>
  <thead>
    <tr>
      <th>Benchmark Test Name</th>
      <th>Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>callbackInterfaceUsingInheritance</td>
      <td>0.100 ns</td>
    </tr>
    <tr>
      <td>basicCCallback</td>
      <td>0.198 ns</td>
    </tr>
    <tr>
      <td>callingMemberThroughStandardCFunction</td>
      <td>0.199 ns</td>
    </tr>
    <tr>
      <td>stdFunctionRef</td>
      <td>0.524 ns</td>
    </tr>
    <tr>
      <td>templatingTheMemberFunctionAndInstance</td>
      <td>1.42 ns</td>
    </tr>
    <tr>
      <td>stdFunctionWithLambdas</td>
      <td>1.67 ns</td>
    </tr>
    <tr>
      <td>stdFunctionWithBind</td>
      <td>2.14 ns</td>
    </tr>
    <tr>
      <td>staticVariablesWithTemplating</td>
      <td>2.20 ns</td>
    </tr>
  </tbody>
</table>


The sad (but in some sense hardly surprising) news is that if you need the absolute fastest performance, nothing can beat a C-style callback (including a C-style callback that then calls a member function through a shared (e.g. global or file scoped) variable). On the other end of the spectrum, using `std::function` with `std::bind` gave the slowest performance, being about 10x slower than the C-style callback! The middle ground was `function_ref`, which was only about 2-3x slower than the C-style callback.

## C++ Callback Libraries

### cpgf

Website: <a href="http://www.cpgf.org/" target="_blank">http://www.cpgf.org/</a>

* Uses the signals and slots syntax
* Callbacks can be functions, member methods, virtual methods...
* Really easy to use syntax.
* Powerful.

License: Apache License, Version 2.0
  
### libsigc++

Website: <a href="http://libsigc.sourceforge.net/" target="_blank">http://libsigc.sourceforge.net/</a>

* Supports signals and slots.
* Many features.
* Powerful.
* Uses advanced C++ compiler features.
* Somewhat complex to use

License: GNU Library General Public License

### Vlpp

[Vlpp is an open source C++ library](https://github.com/vczh-libraries/Vlpp) which provides cross-platform replacements for `<functional>` (among other std libraries). Sometimes, the `<functional>` library provided by the C++ standard library will not work on embedded systems (I've had it work fine on some embedded platforms and not on others). _Vlpp_ can be used as a substitute, allowing you to use `vl::Func<void(void)>` to replace `std::function<void(void)>` and implement callbacks in this manner on embedded platforms.

## External Resources

[Callbacks In C++ Using Template Functors](http://www.tutok.sk/fastgl/callback.html) is a great page explaining and analysing all the different ways for implementing callbacks in C++. This includes the functional model, single rooted hierarchy, parameterize the caller, callee mix-in, and functors (which they promote).

[The Type-safe Callbacks In C++](http://www.codeproject.com/Articles/6136/Type-safe-Callbacks-in-C) library on the Code Project gives a great, complete callback library for C++ which allows callbacks with 0 to 5 input arguments.

[Functors to Encapsulate C and C++ Function Pointers](http://www.newty.de/fpt/functor.html) is a short and simple tutorial on using functors.

{/* ============================================================================================ */}
{/* REFERENCES */}
{/* ============================================================================================ */}

[^cpp-reference-std-function-ref]: cppreference.com. _std::function_ref_ [documentation]. Retrieved 2025-04-25, from https://en.cppreference.com/w/cpp/utility/functional/function_ref.
[^github-zhihaoy-nontype-functional]: GitHub. _zhihaoy/nontype_functional_ [repo]. Retrieved 2025-04-25, from https://github.com/zhihaoy/nontype_functional.
