---
// @ts-nocheck
import StarlightPage from '@astrojs/starlight/components/StarlightPage.astro';
import { getCollection } from 'astro:content';

import Aside from 'src/components/Aside.astro';
import ChildPages from 'src/components/ChildPages.astro';
import CircuitJs from 'src/components/CircuitJs.astro';
import Image from 'src/components/Image.astro';
import IRef from '@components/IRef.astro';
import Table from 'src/components/Table.astro';
import WarningIsNotes from 'src/components/WarningIsNotes.astro';
import WrappableRow from 'src/components/WrappableRow.astro';

import { getRoutablePages, getPageHierarchy, convertNodesToSidebarData, findPageNodeBySlug } from 'src/js/PageHierarchy';
import { correctUpdatesSlugs, getAllCollections } from 'src/js/Collections';

export async function getStaticPaths() {

  // let pagesCollection = await getCollection('pages');
  // pagesCollection = [];

  // All pages in the updates collection will have a slug prefixed with "updates/"
  // let updatesCollection = await getCollection('updates');
  // correctUpdatesSlugs(updatesCollection);

  // Merge the updates collection into the pages collection
  // const combinedCollection = (pagesCollection as any).concat(updatesCollection);

  let combinedCollection = await getAllCollections();

  // Uncomment this line if you want to test code logic with a smaller collection
  // let pagesCollection = await getCollection('test');
  
  // Trim down to first 10
  // combinedCollection = combinedCollection.slice(0, 2);

  // Convert the collection into a hierarchy of pages, where each page
  // is represented as a node with potential children nodes.
  
  const routablePages = getRoutablePages(combinedCollection);
  const pageHierarchy = getPageHierarchy(routablePages);
  const sidebarData = convertNodesToSidebarData(pageHierarchy);

  class BreadcrumbItem {
    label: string;
    slug: string;

    constructor(label: string, slug: string) {
      this.label = label;
      this.slug = slug;
    }
  }

  let staticPaths = [];
  for (let pageRoute of routablePages) {

    // These slugs do not have a leading / nor a trailing /
    if (pageRoute.slug === 'index') {
      pageRoute.slug = undefined;
    }

    //================================================================================
    // Breadcrumb Generation
    //================================================================================
    const pageNode = findPageNodeBySlug(pageRoute.slug, pageHierarchy);
    // console.log('Used slug:', pageRoute.slug, 'to find page node:', pageNode);

    // Generate breadcrumb trail for the page
    let breadcrumbs: BreadcrumbItem[] = [];
    let currentNode = pageNode;
    while (currentNode && currentNode.parent) {
      breadcrumbs.unshift(new BreadcrumbItem(currentNode.fileData?.title || currentNode.label, currentNode.slug || ''));
      currentNode = currentNode.parent;
    }
    // // Add home page as the first breadcrumb
    breadcrumbs.unshift(new BreadcrumbItem('Home', '/'));

    //================================================================================
    // Page Aliases
    //================================================================================
    // Need to create additional paths if the page contains aliases in it's frontmatter
    const aliases = pageRoute.data.aliases;
    if (aliases) {
      for (let alias of aliases) {
        staticPaths.push({
          params: { slug: alias },
          props: { 
            aliasTo: pageRoute.slug,
            // Nothing more is needed for the alias page
            frontmatter: undefined,
            render: undefined,
            sidebarData: undefined,
          },
        });
      }
    }

    //================================================================================
    // Main Page Route Creation
    //================================================================================
    staticPaths.push({
      params: { slug: pageRoute.slug },
      props: { 
        aliasTo: undefined,
        frontmatter: pageRoute.data,
        render: pageRoute.render,
        sidebarData: sidebarData,
        breadcrumbs: breadcrumbs,
      },
    });
  }

  return staticPaths;
}

const { aliasTo, frontmatter, render, sidebarData, breadcrumbs } = Astro.props;

// Check if this page is an alias, and if so, redirect before attempting to render page
if (aliasTo) {
  return Astro.redirect(`/${aliasTo}/`);
}

const { Content, headings, remarkPluginFrontmatter } = await render();
---
<!-- Any unsupported entries will be stripped from the frontmatter. Can add new props though! -->
<StarlightPage 
  frontmatter={{ ...frontmatter }}
  headings={headings}
  sidebar={sidebarData.items as any}
  customFrontmatter={frontmatter}
  breadcrumbs={breadcrumbs}
>
  <Content components={{
    Aside: Aside,
    ChildPages: ChildPages,
    CircuitJs: CircuitJs,
    Image: Image,
    IRef: IRef,
    Table: Table,
    WarningIsNotes: WarningIsNotes,
    WrappableRow: WrappableRow,
  }} /> 
</StarlightPage>